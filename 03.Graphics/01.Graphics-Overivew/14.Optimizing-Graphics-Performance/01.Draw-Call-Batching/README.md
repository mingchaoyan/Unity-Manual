# Draw Call Batching
为了在屏幕上画一个物体，引擎必须提出一个draw call给graphics API(比如OpenGL或者Direct3D)。Draww call经常是非常耗的，因为显卡需要做大量工作，在CPU这端会产生大量开销。在draw call之间的状态切换也是比较常见的，这会这会导致GPU这边比较耗。

Unity可以用静态合批来处理这些。静态合批的目标是重组mesh，从而得到更好的性能。因为合批以后一个比较的的mesh将会被渲染，而不是一堆小的mesh被渲染（这通常比较耗）。Unity只会在同样的资源上循环渲染不同的区域。这会有显著的效果。

内建的合批将在合简单的几何物体上有显著的效果。在Unity5.0中，只有一个索引buffer，然后一个draw call被提交然后每个子mesh开始渲染。

## 材质
objects之间共享同一个材质的才能被渲染。所以如果你想要获得比较好的合批，你需要在不同的object之间共享很多材质。

当你有两块相同的材质，但是只在纹理上不一样，你可以使用达图集工具，把它们打到一个图集中，当纹理处于同一个图集，你就可以使用一个材质了。

如果你想要在脚本中使用共享材质，请注意使用Renderer.sharedMaterial而不是Renderer.maerial。因为前者还会创建一份材质拷贝。

## 动态合批
Unity能够自动把动态的物体合进同一个draw call，如果他们是共享同一个材质以及符合其他标准。动态合批自动完成，并不需要你做啥其他动作。
技巧：
* 动态合批在每个顶点傻姑娘会有一定消耗，所以动态合批只能用于顶点数小于900的（注意如果你的shader使用了顶点位置，法线，或者UV那么这个数量就会是300；设置如果你用了顶点位置，法线，UV0，UV1，切线，那么只有180。这个限制未来可能会变）
* 一般而言，物体应该在同一个transform大小。(例外情况 non－uniform物体)
* 使用不同的材质实例，即使它们是一样的，但是这也会不能合批
* 使用了有额外渲染参数的lightmaps
* Multi-pass shader 将会破坏合批
* 接受实时阴影的物体将不会被合批

## 静态合批 
静态合批允许引擎为不同形状的几何体降低draw call（针对那些并不移动以及共享同一材质的）。静态合批比动态合批效果明显，但是会使用更多内存。你需要静态合批因为这会产生更少的CPU消耗。

为了使用静态合批，你需要显式标记某个物体为静态，然后它将不能移动，不能旋转和改变大小。在Inspector上标记物体为静态。

使用动态合批将会使用额外的内存来存放合并的几何体。如果一些object共享同一个几何体，那么在编辑器或者真机环境中将会有为每一object产生一份拷贝。如果你需要牺牲渲染性能避免过多的内存消耗，这可能不是一个好方法。比如给浓密的森林标记静态将会产生很多内存消耗。

在Unity内部，静态合批的原理是把静态物体转换到世界坐标系中，给每个物体创建一个大的顶点索引buffer。然后这些物体就在同一个比较“便宜的”draw call中了。所以从技术上来说这也没有节省"3D API draw call"，而是节省了状态切换。

## 其他合批建议
目前只会把Mesh 和 Particle System这两个合批。所以skinned meshed，cloth，trail 等其他渲染组件不会被合批

半透明shader经常需要在透明度上有变化。

有些Unity的渲染还没有合批，比如阴影，相机，或者GUI
